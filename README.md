# Manual de Estilo para Funciones DPM en Python

Este manual ofrece una gu√≠a para escribir funciones en Python de forma **clara, modular, trazable y consistente**. Su objetivo es facilitar el mantenimiento, la reutilizaci√≥n y la depuraci√≥n del c√≥digo.

---

## 1. Introducci√≥n y Objetivos

- **Prop√≥sito:** Establecer directrices para la creaci√≥n de funciones que sean f√°ciles de mantener, reutilizar y depurar.
- **Enfoque:** C√≥digo limpio, validaciones tempranas, mensajes de log estandarizados y organizaci√≥n modular.

---

## 2. Nomenclatura y Convenciones

### 2.1. Nombres de Funciones

- **Formato:** Usa *snake_case* (min√∫sculas y guiones bajos).
- **Estructura Sugerida:**  
  **verbo** + **objeto/√°mbito** + **detalle (opcional)** + **resultado** + **tipo de dato**  
  *Ejemplos:*  
  - `SQL_generate_report_str()`  
  - `API_fetch_data_dic()`  
  - `leads_calculate_conversion_float()`
- **Siglas:** Se escriben en **MAY√öSCULAS** (ej.: SQL, API, JSON).

### 2.2. Nombres de Variables

- Aplica el mismo esquema que para funciones, a√±adiendo un **sufijo de tipo**:  
  `_str`, `_int`, `_float`, `_bool`, `_dic`, `_list`, `_df`, `_set`, `_tuple`.
- *Ejemplos:*  
  - `campaign_cost_total_float`  
  - `SQL_query_str`  
  - `user_data_dic`

---

## 3. Estructura y Documentaci√≥n de Funciones

### 3.1. Definici√≥n y Par√°metros

- **Argumento √önico:**  
  Toda funci√≥n debe recibir un √∫nico par√°metro, usualmente un diccionario (`config: dict`), para agrupar los valores de entrada.
- **Agrupaci√≥n de Par√°metros:**  
  Si se requieren m√∫ltiples entradas, se deben consolidar en el diccionario para mantener la uniformidad.

### 3.2. Docstrings Completos

Cada funci√≥n debe incluir un docstring que contenga:
- **Descripci√≥n breve** de la funci√≥n.
- **Detalle de par√°metros:** nombre, tipo y descripci√≥n.
- **Valor de retorno:** tipo y descripci√≥n.
- **Excepciones:** Detalle de posibles errores (`Raises`).

#### Ejemplo Base
```python
def SQL_generate_report_str(config: dict) -> str:
    """
    Genera un reporte SQL en forma de cadena.

    Args:
        config (dict):
            - query (str): Consulta SQL.
            - format (str, opcional): Formato de salida (default: 'csv').

    Returns:
        str: Reporte generado en formato cadena.

    Raises:
        ValueError: Si falta el par√°metro 'query'.
    """
    query_str = config.get('query')
    if not query_str:
        raise ValueError("[VALIDATION [ERROR ‚ùå]] Falta 'query' en config.")
    
    return f"Reporte para: {query_str}"
```

---

## 4. Validaci√≥n de Par√°metros

- **Validaci√≥n Inicial:**  
  Realiza la verificaci√≥n de todos los par√°metros obligatorios al inicio de la funci√≥n.
- **Mensajes de Error:**  
  Usa mensajes claros con el prefijo `[VALIDATION [ERROR ‚ùå]]`.

*Ejemplo:*
```python
if leads_total_int == 0:
    raise ValueError("[VALIDATION [ERROR ‚ùå]] Leads no puede ser cero.")
```

---

## 5. Estilo de C√≥digo y Formato

### 5.1. Formato y Espaciado

- **Indentaci√≥n:** 4 espacios por nivel.
- **Espaciado entre funciones:** 2 l√≠neas en blanco.
- **L√≠neas en Blanco:** Coloca una l√≠nea en blanco antes del `return` si hay l√≥gica previa para mejorar la legibilidad.

### 5.2. Importaciones

- **Globales:** Col√≥calas al inicio del m√≥dulo.
- **Locales:** Importa dentro de la funci√≥n solo si es necesario para reducir dependencias globales.

---

## 6. Seguimiento y Mensajes de Log usando √∫nciamente print()

### 6.1. Mensajes Inmediatos

Utiliza `print(..., flush=True)` para asegurar que los mensajes se impriman sin retrasos.

### 6.2. Componentes del Mensaje

- **CABECERA:** Elemento opcional para resaltar el inicio de una secci√≥n clave del log. Mejora la legibilidad agrupando eventos relacionados.

Ejemplos:

```plaintext
üîπüîπüîπ [START ‚ñ∂Ô∏è] Carga de Datos üîπüîπüîπ
üîπüîπüîπ [PROCESSING üîÑ] Transformando Datos üîπüîπüîπ
```

- **DESCRIPTOR:** T√©rmino en may√∫sculas que describe claramente la acci√≥n o fase actual del proceso. Ejemplos habituales:

  - `FILE SEARCH`
  - `METADATA EXTRACTION`
  - `VALIDATION`
  - `PROCESSING`
  - `BACKUP`

- **STATE:** Estado espec√≠fico del proceso con etiquetas est√°ndar adaptadas al contexto:

  - **START ‚ñ∂Ô∏è:** Indica el inicio del proceso.
  - **INFO ‚ÑπÔ∏è:** Informaci√≥n intermedia relevante o puntual.
  - **SUCCESS ‚úÖ / FINISHED ‚úÖ:** Finalizaci√≥n exitosa.
  - **WARNING ‚ö†Ô∏è:** Situaciones que requieren atenci√≥n sin interrumpir el flujo.
  - **ERROR ‚ùå / FAILED ‚ùå:** Errores cr√≠ticos que afectan la ejecuci√≥n.

### Aplicaci√≥n Din√°mica

- Comienza cada proceso con `[<DESCRIPTOR> START ‚ñ∂Ô∏è]`.
- Usa `[<DESCRIPTOR> INFO ‚ÑπÔ∏è]` para informaci√≥n adicional relevante.
- Finaliza operaciones con `[<DESCRIPTOR> SUCCESS ‚úÖ]` o `[<DESCRIPTOR> FINISHED ‚úÖ]`.
- En errores cr√≠ticos usa `[<DESCRIPTOR> ERROR ‚ùå]` o `[<DESCRIPTOR> FAILED ‚ùå]`.
- Usa `[<DESCRIPTOR> WARNING ‚ö†Ô∏è]` para alertas sobre posibles problemas.
- Indica progreso mediante barras, porcentajes o contadores parciales/totales.
- Cierra cada proceso con m√©tricas y estad√≠sticas relevantes.

Aplicaci√≥n Din√°mica

### Ejemplo

```plaintext
üîπüîπüîπ [START ‚ñ∂Ô∏è] Proceso de B√∫squeda de Archivos üîπüîπüîπ
[FILE SEARCH START ‚ñ∂Ô∏è] Iniciando b√∫squeda en la ruta especificada. (Progreso: 0%)
[PROGRESS] [‚ñà_________] 10.75% completado (50/465)
[LOCATED FILE INFO ‚ÑπÔ∏è] Archivo encontrado: video.mp4 (Ruta: /ruta/del/archivo). (Progreso: 25%)
[PROGRESS] [‚ñà‚ñà‚ñà‚ñà______] 50.32% completado (234/465)
[LOCATED FILE INFO ‚ÑπÔ∏è] Archivo encontrado: audio.mp3 (Ruta: /ruta/del/archivo). (Progreso: 50%)
[PROGRESS] [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà___] 75.48% completado (351/465)
[LOCATED FILE INFO ‚ÑπÔ∏è] Archivo encontrado: imagen.jpg (Ruta: /ruta/del/archivo). (Progreso: 75%)
[FILE SEARCH SUCCESS ‚úÖ] B√∫squeda finalizada. Archivos encontrados: 465. Tiempo empleado: 1m 23s. Tama√±o total: 3.5 GB. (Progreso: 100%)

üîπüîπüîπ [METRICS üìä] Resumen de Ejecuci√≥n üîπüîπüîπ
[METRICS INFO ‚ÑπÔ∏è] Resumen de ejecuci√≥n:
  - Archivos procesados: 465
  - Tama√±o total: 3.5 GB
  - Tiempo total de b√∫squeda: 1m 23s
  - Tiempo de procesamiento de metadatos: 45s
  - Advertencias detectadas: 1
[END FINISHED ‚úÖ] Tiempo total de ejecuci√≥n: 2m 08s
```

---

## 7. Manejo de Errores

- **Bloques try-except:**  
  Envuelve operaciones cr√≠ticas (descarga, importaci√≥n din√°mica, lectura de datos) para capturar y registrar errores.
- **Mensajes Claros:**  
  Acompa√±a los errores con el prefijo correspondiente (por ejemplo, `[EXTRACTION [ERROR ‚ùå]]`) y detalles √∫tiles.

---

## 8. Funciones Auxiliares (Subfunciones)

- **Definici√≥n Interna:**  
  Si la funcionalidad es espec√≠fica de una funci√≥n ‚Äúmadre‚Äù, define subfunciones dentro de ella.
- **Nomenclatura:**  
  Usa un gui√≥n bajo inicial (`_`) para indicar que son internas y no forman parte de la API p√∫blica.

*Ejemplo:*
```python
def load_custom_libs(config_list: list) -> None:
    def _download_module_from_github(module_path: str) -> str:
        # L√≥gica para descargar el m√≥dulo...
        return temp_file_path
    # Resto de la funci√≥n...
```

---

## 9. Organizaci√≥n y Orden del C√≥digo

- **Orden Alfab√©tico:**  
  Las funciones deben ordenarse alfab√©ticamente para facilitar la b√∫squeda y mantenimiento.
- **Agrupaci√≥n L√≥gica:**  
  Organiza funciones relacionadas en m√≥dulos o secciones dentro del archivo.

---

## 10. Consideraciones Adicionales

- **Recarga de M√≥dulos:**  
  En importaciones din√°micas, elimina versiones previas y usa `importlib.invalidate_caches()` para cargar la versi√≥n actual.
- **Gesti√≥n de Archivos Temporales:**  
  Utiliza la librer√≠a `tempfile` para manejar archivos descargados y aseg√∫rate de su correcta eliminaci√≥n o mantenimiento.
- **Zonas Horarias:**  
  Emplea `zoneinfo` (o `pytz`) para ajustar fechas seg√∫n la zona horaria requerida (ej.: "Europe/Madrid").

---

## 11. Autenticaci√≥n Din√°mica con `ini_environment_identificated`

Esta estrategia permite que las funciones seleccionen autom√°ticamente el m√©todo de acceso a las credenciales seg√∫n el entorno:

- **Entorno LOCAL:**  
  - Valor: `"LOCAL"`  
  - M√©todo: Usa `json_keyfile_local`.

- **Entorno GOOGLE COLAB:**  
  - Valor: `"COLAB"`  
  - M√©todo: Usa `json_keyfile_colab`.

- **Entornos GCP (incluyendo COLAB_ENTERPRISE):**  
  - Valor: `"COLAB_ENTERPRISE"` o un `project_id` (por ejemplo, `"mi-proyecto"`)  
  - M√©todo: Utiliza Secret Manager mediante `json_keyfile_GCP_secret_id`.  
    - En `"COLAB_ENTERPRISE"`, el `project_id` se extrae de la variable `GOOGLE_CLOUD_PROJECT`.

### Ejemplo de Configuraci√≥n
```python
config = {
    "ini_environment_identificated": "COLAB",  # Opciones: "LOCAL", "COLAB", "COLAB_ENTERPRISE" o un project_id
    "json_keyfile_local": r"D://ruta/a/credenciales.json",    # Usado para "LOCAL"
    "json_keyfile_colab": "/ruta/a/credenciales.json",          # Usado para "COLAB"
    "json_keyfile_GCP_secret_id": "mi-secret-id",              # Usado para entornos GCP
    # Otros par√°metros...
}
```

---

## 12. Ejemplo Completo de Funci√≥n con Buenas Pr√°cticas

Este ejemplo ilustra el proceso completo, desde la descarga (si es necesario) hasta la importaci√≥n y reporte del m√≥dulo, incluyendo validaciones, mensajes de log y manejo de errores.

```python
# @title load_custom_libs()
def load_custom_libs(config_list: list) -> None:
    """
    Carga din√°micamente uno o varios m√≥dulos a partir de una lista de diccionarios de configuraci√≥n.

    Cada diccionario debe incluir:
      - module_host (str): "GD" para rutas locales o "github" para archivos en GitHub.
      - module_path (str): Ruta local o URL al archivo .py.
      - selected_functions_list (list, opcional): Lista de nombres de funciones/clases a importar.
        Si est√° vac√≠o, se importan todos los objetos definidos en el m√≥dulo.

    Para m√≥dulos alojados en GitHub, la URL se transforma a formato raw y se descarga en un archivo temporal.
    La fecha de √∫ltima modificaci√≥n se muestra ajustada a la zona horaria de Madrid.

    Returns:
        None

    Raises:
        ValueError: Si faltan par√°metros obligatorios.
    """
    import os
    import sys
    import importlib
    import inspect
    import datetime
    from zoneinfo import ZoneInfo
    import tempfile
    import requests

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Subfunciones Auxiliares ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def _imprimir_encabezado(mensaje: str) -> None:
        print(f"\nüîπüîπüîπ {mensaje} üîπüîπüîπ\n", flush=True)

    def _download_module_from_github(module_path: str) -> str:
        if "github.com" in module_path:
            raw_url = module_path.replace("github.com", "raw.githubusercontent.com").replace("/blob", "")
        else:
            raw_url = module_path
        try:
            print(f"[EXTRACTION [START ‚ñ∂Ô∏è]] Descargando m√≥dulo desde GitHub: {raw_url}", flush=True)
            response = requests.get(raw_url)
            if response.status_code != 200:
                error_details = response.text[:200].strip()
                print(f"[EXTRACTION [ERROR ‚ùå]] No se pudo descargar el archivo desde {raw_url}. C√≥digo de estado: {response.status_code}. Detalles: {error_details}", flush=True)
                return ""
            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".py")
            temp_file.write(response.content)
            temp_file.close()
            print(f"[EXTRACTION [SUCCESS ‚úÖ]] Archivo descargado y guardado en: {temp_file.name}", flush=True)
            return temp_file.name
        except Exception as e:
            print(f"[EXTRACTION [ERROR ‚ùå]] Error al descargar el archivo desde GitHub: {e}", flush=True)
            return ""

    def _get_defined_objects(module, selected_functions_list: list) -> dict:
        all_objects = inspect.getmembers(module, lambda obj: inspect.isfunction(obj) or inspect.isclass(obj))
        defined_objects = {name: obj for name, obj in all_objects if getattr(obj, "__module__", "") == module.__name__}
        if selected_functions_list:
            return {name: obj for name, obj in defined_objects.items() if name in selected_functions_list}
        return defined_objects

    def _get_module_mod_date(module_path: str) -> datetime.datetime:
        mod_timestamp = os.path.getmtime(module_path)
        mod_date = datetime.datetime.fromtimestamp(mod_timestamp, tz=ZoneInfo("Europe/Madrid"))
        return mod_date

    def _import_module(module_path: str):
        module_dir, module_file = os.path.split(module_path)
        module_name, _ = os.path.splitext(module_file)
        if module_dir not in sys.path:
            sys.path.insert(0, module_dir)
            print(f"[TRANSFORMATION [INFO ‚ÑπÔ∏è]] Directorio agregado al sys.path: {module_dir}", flush=True)
        if module_name in sys.modules:
            del sys.modules[module_name]
            print(f"[TRANSFORMATION [INFO ‚ÑπÔ∏è]] Eliminada versi√≥n previa del m√≥dulo: {module_name}", flush=True)
        try:
            print(f"[LOAD [START ‚ñ∂Ô∏è]] Importando m√≥dulo: {module_name}", flush=True)
            module = importlib.import_module(module_name)
            module = importlib.reload(module)
            print(f"[LOAD [SUCCESS ‚úÖ]] M√≥dulo '{module_name}' importado correctamente.", flush=True)
            return module, module_name
        except Exception as e:
            print(f"[LOAD [ERROR ‚ùå]] Error al importar el m√≥dulo '{module_name}': {e}", flush=True)
            return None, module_name

    def _print_module_report(module_name: str, module_path: str, mod_date: datetime.datetime, selected_objects: dict) -> None:
        print("\n[METRICS [INFO ‚ÑπÔ∏è]] Informe de carga del m√≥dulo:", flush=True)
        print(f"  - M√≥dulo: {module_name}", flush=True)
        print(f"  - Ruta: {module_path}", flush=True)
        print(f"  - Fecha de √∫ltima modificaci√≥n: {mod_date}", flush=True)
        if not selected_objects:
            print("  - [WARNING ‚ö†Ô∏è] No se encontraron objetos para importar.", flush=True)
        else:
            print("  - Objetos importados:", flush=True)
            for name, obj in selected_objects.items():
                obj_type = type(obj).__name__
                doc = inspect.getdoc(obj) or "Sin documentaci√≥n"
                first_line = doc.split("\n")[0]
                print(f"      ‚Ä¢ {name} ({obj_type}): {first_line}", flush=True)
        print(f"\n[END [FINISHED ‚úÖ]] M√≥dulo '{module_name}' actualizado e importado en globals().\n", flush=True)

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Proceso Principal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    _imprimir_encabezado("[START ‚ñ∂Ô∏è] Iniciando carga de m√≥dulos personalizados")
    for config in config_list:
        module_host = config.get("module_host")
        module_path = config.get("module_path")
        selected_functions_list = config.get("selected_functions_list", [])

        if module_host == "github":
            temp_module_path = _download_module_from_github(module_path)
            if not temp_module_path:
                continue
            module_path = temp_module_path

        if not os.path.exists(module_path):
            print(f"[VALIDATION [ERROR ‚ùå]] La ruta del m√≥dulo no existe: {module_path}", flush=True)
            continue

        importlib.invalidate_caches()
        mod_date = _get_module_mod_date(module_path)
        module, module_name = _import_module(module_path)
        if module is None:
            continue

        selected_objects = _get_defined_objects(module, selected_functions_list)
        globals().update(selected_objects)
        _print_module_report(module_name, module_path, mod_date, selected_objects)
```
